/* ------------------------------------------------ *
 *  Written by:      Nagy Balint                    *
 *  Contact:         b.nagy.balint@gmail.com        *
 *                                                  *
 *  This file can be used/improved/redistributed    *
 *  under GNU public license                        *
 *                                                  *
 *  Nagy Balint (C) 2010                            *
 * ------------------------------------------------ */

/* ------------------------------------------------ *
 *  Library:         bcore                          *
 *  Version:         0.8.00                         *
 *  Date:            19-01-2011                     *
 * ------------------------------------------------ */

#include "Random.h"

#include "Assist/Common.h"
#include "Assist/MathCommon.h"

/**
 * Default seed for MTRandomizers
 */
#define MT_DEFAULT_SEED      ( unsigned int(1U) )
#define MT_DATA_SIZE         ( unsigned int(624U) )

/**
 * Constructor. Initializes the new object with default settings.
 */
MTRandomizer::MTRandomizer () :MTdata(0), MTindex(0) {
   MTdata = new unsigned int[MT_DATA_SIZE];
   initialize(MT_DEFAULT_SEED);
}

/**
 * Constructor. Initializes the new object with given seed.
 *
 * @param seed the seed for the new object
 */
MTRandomizer::MTRandomizer (const unsigned int seed) :MTdata(0), MTindex(0) {
   MTdata = new unsigned int[MT_DATA_SIZE];
   initialize(seed);
}

MTRandomizer::~MTRandomizer () {
   delete[] MTdata;
}

/**
 * Generate new MTdata vector. For details about implementation, see:
 * http://en.wikipedia.org/wiki/Mersenne_twister#Pseudocode .
 */
void MTRandomizer::generate () {
   unsigned int y;
   for (unsigned int i = 0; i < MT_DATA_SIZE; i++) {
      y = (MTdata[i] & 0x80000000) | (MTdata[(i + 1) % MT_DATA_SIZE] & 0x7fffffff); // 32nd bit of MT[i] and last 31 bit of MT[i+1]
      MTdata[i] = MTdata[(i + 397) % MT_DATA_SIZE] ^ (y >> 1);
      if (y % 2 != 0) // y is odd
         MTdata[i] ^= 0x9908b0df; // 2567483615
   }
}

/**
 * Initialize MTdata vector with seed as MTdata[0]. Every other MTdata[i] is
 * calculated using this seed value. For details about implementation, see:
 * http://en.wikipedia.org/wiki/Mersenne_twister#Pseudocode .
 *
 * @param seed the seed (MTdata[0]) for randomization
 */
void MTRandomizer::initialize (const unsigned int seed) {
   MTdata[0] = seed;
   for (unsigned int i = 1; i < MT_DATA_SIZE; i++)
      MTdata[i] = 0x6c078965 * (MTdata[i - 1] ^ (MTdata[i - 1] >> 30)) + i; // 1812433253
}

/**
 * Set new seed for randomization. Reinitializes MTdata with this seed.
 * Resets MTindex, causing the next randomize() call to recalculate MTdata
 * with generate().
 *
 * @param seed the seed (MTdata[0]) to set
 */
void MTRandomizer::seed (const unsigned int seed) {
   MTindex = 0;
   initialize(seed);
}

/**
 * Set seed for randomization to default. Reinitializes MTdata with this seed.
 * Resets MTindex, causing the next randomize() call to recalculate MTdata
 * with generate().
 */
void MTRandomizer::seed () {
   MTindex = 0;
   initialize(MT_DEFAULT_SEED);
}

/**
 * Randomize new number with current settings. For details about
 * implementation, see:
 * http://en.wikipedia.org/wiki/Mersenne_twister#Pseudocode .
 *
 * @return random number generated by the algorithm
 */
unsigned int MTRandomizer::random () {

   if (MTindex == 0)
      generate();

   unsigned int y = MTdata[MTindex];
   y ^= (y >> 11);
   y ^= ((y << 7) & 0x9d2c5680); // 2636928640
   y ^= ((y << 15) & 0xefc60000); // 4022730752
   y ^= (y >> 18);

   MTindex = (MTindex + 1) % MT_DATA_SIZE;

   return y;
}

/**
 * Randomize n new numbers with current settings and store them in ptr.
 * There should be enough place for n numbers in ptr. If n=0, no number
 * is generated. For details about implementation, see:
 * http://en.wikipedia.org/wiki/Mersenne_twister#Pseudocode .
 *
 * @param ptr array to store generated values
 * @param n number of randomized values
 */
unsigned int* MTRandomizer::random (unsigned int* ptr, unsigned int n) {

   unsigned int y;

   for (unsigned int i = 0; i < n; i++) {

      if (MTindex == 0)
         generate();

      y = MTdata[MTindex];
      y ^= (y >> 11);
      y ^= ((y << 7) & 0x9d2c5680); // 2636928640
      y ^= ((y << 15) & 0xefc60000); // 4022730752
      y ^= (y >> 18);

      MTindex = (MTindex + 1) % MT_DATA_SIZE;

      ptr[i] = y;
   }

   return ptr;
}



/// Randomize integer in [a, b-1].
unsigned int MTRandomizer::random (unsigned int a, unsigned int b) {
   Assert(a <= b);
   return a + (random() % (b - a + 1));
}
/// Randomize float with uniform distribution in [0,1].
float  MTRandomizer::randomUniform () {
   const unsigned int num = Random();
   const unsigned int den = MTRandomizer::randMax();
   return (float(num) / float(den));
}
/// Randomize float with uniform distribution in [min,max].
float  MTRandomizer::randomUniform (float min, float max) {
   Assert(min <= max);
   return min + randomUniform() * (max - min);
}
/// Randomize float with uniform distribution in [-1,1].
/// Same as randomUniform(-1,1).
float  MTRandomizer::randomNormalized () {
   return -1.0f + randomUniform() * 2.0f;
}
/// Randomize float with Standard Gaussian (Normal) distribution.
/// Same as randomGaussian(0,1).
/// Based on Marsaglia polar method method
float  MTRandomizer::randomGaussian () {
   float uv[2];
   float s;

   do {
      randomUniform(uv, 2);
      uv[0] = uv[0] * 2.0f - 1.0f;
      uv[1] = uv[1] * 2.0f - 1.0f;
      s = uv[0] * uv[0] + uv[1] * uv[1];
   } while (s >= 1.0f);

   return uv[0] * Math::Sqrt(-2.0f * Math::Log(s) / s);
}
/// Randomize float with Gaussian (Normal) distribution.
/// Parameter m is the mean value, d is the standard deviation
float  MTRandomizer::randomGaussian (float m, float d) {
   float uv[2];
   float s;

   do {
      RandomUniform(uv, 2);
      uv[0] = uv[0] * 2.0f - 1.0f;
      uv[1] = uv[1] * 2.0f - 1.0f;
      s = uv[0] * uv[0] + uv[1] * uv[1];
   } while (s >= 1.0f);

   return m + uv[0] * Math::Sqrt(-2.0f * Math::Log(s) * d / s);
}

/// Randomize integer in [a, b-1] n times and store it in ptr.
unsigned int* MTRandomizer::random (unsigned int* ptr, unsigned int n, unsigned int a, unsigned int b) {
   random(ptr, n);
   for(unsigned int i=0; i<n; i++) {
      ptr[i] =  a + (ptr[i] % (b-a+1));
   }
   return ptr;
}
/// Randomize float with uniform distribution in [0,1] n times and store it in ptr.
float* MTRandomizer::randomUniform (float* ptr, unsigned int n) {
   const float den = float(MTRandomizer::randMax());
   for (unsigned int i = 0; i < n; i++) {
      ptr[i] = static_cast<float> (Random()) / den;
   }
   return ptr;
}
/// Randomize float with uniform distribution in [min,max] n times and store it in ptr.
float* MTRandomizer::randomUniform (float* ptr, unsigned int n, float min, float max) {
   const float den = float(MTRandomizer::randMax());
   for (unsigned int i = 0; i < n; i++) {
      ptr[i] = min + (static_cast<float> (Random()) / den) * (max-min);
   }
   return ptr;
};
/// Randomize float with uniform distribution in [-1,1] n times and store it in ptr.
/// Same as randomUniform(ptr,n,-1,1).
float* MTRandomizer::randomNormalized (float* ptr, unsigned int n) {
   randomUniform(ptr,n,-1.0f,1.0f);
   return ptr;
}
/// Randomize float with Standard Gaussian (Normal) distribution n times and store it in ptr.
/// Same as randomGaussian(ptr,n,0,1).
float* MTRandomizer::randomGaussian (float* ptr, unsigned int n) {
   float uv[2];
   float x,y;
   float s,q;

   unsigned int ready = 0;

   while(ready < n){
      do {
         randomUniform(uv, 2);
         uv[0] = uv[0] * 2.0f - 1.0f;
         uv[1] = uv[1] * 2.0f - 1.0f;
         s = uv[0] * uv[0] + uv[1] * uv[1];
      } while (s >= 1.0f);

      q = Math::Sqrt(-2.0f * Math::Log(s) / s);
      x = uv[0] * q;
      y = uv[1] * q;

      ptr[ready++] = x;
      if(ready<n) ptr[ready++] = y;
   }

   return ptr;
}
/// Randomize float with Gaussian (Normal) distribution n times and store it in ptr.
/// Parameter m is the mean value, d is the standard deviation
float* MTRandomizer::randomGaussian (float* ptr, unsigned int n, float m, float d) {
   float uv[2];
   float x,y;
   float s,q;

   unsigned int ready = 0;

   while(ready < n){
      do {
         randomUniform(uv, 2);
         uv[0] = uv[0] * 2.0f - 1.0f;
         uv[1] = uv[1] * 2.0f - 1.0f;
         s = uv[0] * uv[0] + uv[1] * uv[1];
      } while (s >= 1.0f);

      q = Math::Sqrt(-2.0f * Math::Log(s) * d / s);
      x = m + uv[0] * q;
      y = m + uv[1] * q;

      ptr[ready++] = x;
      if(ready<n) ptr[ready++] = y;
   }

   return ptr;
}



/*static*/MTRandomizer& MTRandomizer::current () {
   static MTRandomizer* inst = new MTRandomizer(MT_DEFAULT_SEED);
   return *inst;
}

/*static*/unsigned int MTRandomizer::randMax () {
   return 0xffffffff;
}
